var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = HashCode2014Sol","category":"page"},{"location":"#HashCode2014Sol-Documentation","page":"Home","title":"HashCode2014Sol Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HashCode2014Sol.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [HashCode2014Sol]","category":"page"},{"location":"#HashCode2014Sol.Problem","page":"Home","title":"HashCode2014Sol.Problem","text":"Problem\n\nStore a Problem that stores a custom default city from HashCode2014 as 'problem', only modifying it by the 'duration' given at construction, as well as its most optimal walk 'solution' and the unique 'distance' traveled in this 'solution' in meters.\n\nFields\n\n'problem::City': a problem city description\n'solution:Solution': a solution to the 'problem' based on the optimal_walk algorithm \n'distance::Int': a record, in meters, of the unique distance traveled by the cars in optimal 'solution'\n\nConstructor\n\nProblem(duration::Int)\nReturns a Problem instance about a default city with the given 'duration' (in seconds)\n\n\n\n\n\n","category":"type"},{"location":"#HashCode2014Sol.add_route!-Tuple{HashCode2014Sol.RouteGrid, HashCode2014Sol.Route}","page":"Home","title":"HashCode2014Sol.add_route!","text":"add_route!(route_grid, route)\n\nRegister a new Route to RouteGrid\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.change_duration-Tuple{HashCode2014.City, Any}","page":"Home","title":"HashCode2014Sol.change_duration","text":"change_duration(city, total_duration)\n\nCreate a new City with a different total_duration and everything else equal.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.check_junction-Tuple{HashCode2014Sol.RouteGrid, Int64, Int64}","page":"Home","title":"HashCode2014Sol.check_junction","text":"check_junction(route_grid, street_idx_1, street_idx_2)\n\nCheck if two Streets of the given indices in the RouteGrid intersect at a Junction. If so, return (true, Junction); else, return (false, nothing)\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.check_route-Tuple{HashCode2014Sol.RouteGrid, Int64, Int64}","page":"Home","title":"HashCode2014Sol.check_route","text":"check_route(route_grid, junction_idx_start, junction_idx_end)\n\nCheck if there exists a Route from two Junctions of the given indices in a RouteGrid. The first index denotes the start junction, and the second index denotes the end junction. If so, return (true, Route). Else, return (false, nothing).\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.city-Tuple{}","page":"Home","title":"HashCode2014Sol.city","text":"city()\n\nReturns default city of type City in HashCode2014 starter \n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.delete_route!-Tuple{HashCode2014Sol.RouteGrid, Int64, Int64}","page":"Home","title":"HashCode2014Sol.delete_route!","text":"delete_route!(route_grid, junc_idx_start, junc_idx_end)\n\nDelete an existing Route between two streets from RouteGrid. The first index denotes the start street, and the second index denotes the end street.\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.distance-Tuple{HashCode2014.Solution, HashCode2014.City}","page":"Home","title":"HashCode2014Sol.distance","text":"distance(solution, city)\n\nFor a city with a feasible solution, returns the unique distance traveled by the cars \n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.get_neighbor_streets-Tuple{HashCode2014.City}","page":"Home","title":"HashCode2014Sol.get_neighbor_streets","text":"city: city for which we want to map neighboring streets for for each street\nreturns a vector neighbors_streets, such that for every junction with index i: every junction index\n    in neighbors_streets[i] can be traveled to from junction i\n    Goes even more specific that if street in neighbors_streets[i]:\n            street.endpointA = i\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.optimal_neighbor-Tuple{Vector{HashCode2014.Street}, Dict{Int64, Int64}}","page":"Home","title":"HashCode2014Sol.optimal_neighbor","text":"optimal_neighbor(neighbors_streets, visited)\n\nPre-requisite: all street.endpointA in neighborsstreets is the same  Parameters:      neighborsstreets: vector of adjacent streets, assumes for all neighbor in neighborsstreets, neighbor.endpointB is travelable                      from same origin node neighbor.endpointA      visited: for all junctions in the corresponding city, a dictionary keeping track of the frequency of how many              times each junction was visited (by any car) Returns the street in neighborsstreets that is least visited, breaks ties by picking left-most entry in neighbors_streets\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.optimal_walk-Tuple{HashCode2014.City}","page":"Home","title":"HashCode2014Sol.optimal_walk","text":"optimal_walk(city)\n\nTakes a city, and returns an itinerary for each car that reduces repeated travel along visited  streets as much as possible.\n\nAlgorithmic description     - Modifies randomwalk to avoid visiting already visited junctions as much as possible     - To avoid repeated calculation, gets a matrix of all the streets travelable from a junction,        switches endpointA and endpointB when bidirectional to put street in the entry of neighborsstreets[endpointB]      - Initialize a dictionary visitednodes that keeps track of how many times a junction has been visited,       by default: 0 times      - For each car:         - Get currentnode's travelable streets          - Filter streets by which ones match the totalduration         - Filter further with optimalneighbor that picks the least visited neighbor         - If no applicable streets, move to next car         - Add the street's endpointB to current car's itinerary, update visited and duration     - Apply Solution(_) to array of all the cars' itineraries in order     - Return that Solution\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.random_walk_distance-Tuple{}","page":"Home","title":"HashCode2014Sol.random_walk_distance","text":"random_walk_distance()\n\nPerforms a random walk on the default city() and returns the unique distance traveled by the cars \n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.replace_route!-Tuple{HashCode2014Sol.RouteGrid, HashCode2014Sol.Route}","page":"Home","title":"HashCode2014Sol.replace_route!","text":"replace_route!(route_grid, new_route)\n\nReplace an existing Route between two junctions in RouteGrid with a new Route  \n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.route-Tuple{Vector{HashCode2014.Street}, Int64, Int64}","page":"Home","title":"HashCode2014Sol.route","text":"route(streets, start_junc_idx, end_junc_idx)\n\nCreate a Route from the in-RouteGrid indices of its start and end junctions\n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.routegrid-Tuple{HashCode2014.City}","page":"Home","title":"HashCode2014Sol.routegrid","text":"routegrid(city)\n\nCreate a RouteGrid from a specified City. \n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.routegrid-Tuple{}","page":"Home","title":"HashCode2014Sol.routegrid","text":"routegrid()\n\nCreate a RouteGrid from the official challenge City. \n\n\n\n\n\n","category":"method"},{"location":"#HashCode2014Sol.upper_limit-Tuple{HashCode2014.City}","page":"Home","title":"HashCode2014Sol.upper_limit","text":"upper_limit(city)\n\nTakes a city and gives an approximate upper limit on the distance that can be feasibly traveled by the cars  Algorithmic description:     Assumes that all streets are travelable from one another, and that it is actually one car traveling for a limit     total of totalduration*nbcars seconds. In that case, we can greedily assume that this one car travels along      only the most \"efficient\" streets, or streets that maximize the meter distance traveled per second.     We sort the streets by this efficiency definition and make the car travel along the most efficient, making sure     it does not exceed (totalduration*nbcars), and keeping track of the total distance being traveled.     At the end, we return this final distance. \n\n\n\n\n\n","category":"method"}]
}
